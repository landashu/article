(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{563:function(r,e,a){"use strict";a.r(e);var s=a(41),t=Object(s.a)({},(function(){var r=this,e=r.$createElement,a=r._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("p",[r._v("文档基于 RocketMQ-4.7.1")]),r._v(" "),a("h2",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[r._v("#")]),r._v(" 基本概念")]),r._v(" "),a("h3",{attrs:{id:"消息模型-message-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息模型-message-model"}},[r._v("#")]),r._v(" 消息模型（Message Model）")]),r._v(" "),a("p",[r._v("RocketMQ 主要由 Producer、Broker、Consumer 三部分组成，其中 Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个 Topic 中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个 Consumer 实例构成。")]),r._v(" "),a("h3",{attrs:{id:"消息生产者-producer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息生产者-producer"}},[r._v("#")]),r._v(" 消息生产者（Producer）")]),r._v(" "),a("p",[r._v("负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到 broker 服务器。RocketMQ 提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要 Broker 返回确认信息，单向发送不需要。")]),r._v(" "),a("h3",{attrs:{id:"消息消费者-consumer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息消费者-consumer"}},[r._v("#")]),r._v(" 消息消费者（Consumer）")]),r._v(" "),a("p",[r._v("负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从 Broker 服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。")]),r._v(" "),a("h3",{attrs:{id:"主题-topic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主题-topic"}},[r._v("#")]),r._v(" 主题（Topic）")]),r._v(" "),a("p",[r._v("表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ 进行消息订阅的基本单位。")]),r._v(" "),a("h3",{attrs:{id:"代理服务器-broker-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理服务器-broker-server"}},[r._v("#")]),r._v(" 代理服务器（Broker Server）")]),r._v(" "),a("p",[r._v("消息中转角色，负责存储消息、转发消息。代理服务器在 RocketMQ 系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。")]),r._v(" "),a("h3",{attrs:{id:"名字服务-name-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#名字服务-name-server"}},[r._v("#")]),r._v(" 名字服务（Name Server）")]),r._v(" "),a("p",[r._v("名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的 Broker IP 列表。多个 Namesrv 实例组成集群，但相互独立，没有信息交换。")]),r._v(" "),a("h3",{attrs:{id:"拉取式消费-pull-consumer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拉取式消费-pull-consumer"}},[r._v("#")]),r._v(" 拉取式消费（Pull Consumer）")]),r._v(" "),a("p",[r._v("Consumer 消费的一种类型，应用通常主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。")]),r._v(" "),a("h3",{attrs:{id:"推动式消费-push-consumer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#推动式消费-push-consumer"}},[r._v("#")]),r._v(" 推动式消费（Push Consumer）")]),r._v(" "),a("p",[r._v("Consumer 消费的一种类型，该模式下 Broker 收到数据后会主动推送给消费端，该消费模式一般实时性较高。")]),r._v(" "),a("h3",{attrs:{id:"生产者组-producer-group"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生产者组-producer-group"}},[r._v("#")]),r._v(" 生产者组（Producer Group）")]),r._v(" "),a("p",[r._v("同一类 Producer 的集合，这类 Producer 发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则 Broker 服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。")]),r._v(" "),a("h3",{attrs:{id:"消费者组-consumer-group"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消费者组-consumer-group"}},[r._v("#")]),r._v(" 消费者组（Consumer Group）")]),r._v(" "),a("p",[r._v("同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。")]),r._v(" "),a("blockquote",[a("p",[r._v("消费组是消费组，生产组是生产组，不要把两个组当一样的。")])]),r._v(" "),a("h3",{attrs:{id:"集群消费-clustering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群消费-clustering"}},[r._v("#")]),r._v(" 集群消费（Clustering）")]),r._v(" "),a("p",[r._v("集群消费模式下，相同 Consumer Group 的每个 Consumer 实例平均分摊消息。")]),r._v(" "),a("h3",{attrs:{id:"广播消费-broadcasting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#广播消费-broadcasting"}},[r._v("#")]),r._v(" 广播消费（Broadcasting）")]),r._v(" "),a("p",[r._v("广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。")]),r._v(" "),a("h3",{attrs:{id:"普通顺序消息-normal-ordered-message"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通顺序消息-normal-ordered-message"}},[r._v("#")]),r._v(" 普通顺序消息（Normal Ordered Message）")]),r._v(" "),a("p",[r._v("普通顺序消费模式下，消费者通过同一个消费队列收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。")]),r._v(" "),a("h3",{attrs:{id:"严格顺序消息-strictly-ordered-message"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#严格顺序消息-strictly-ordered-message"}},[r._v("#")]),r._v(" 严格顺序消息（Strictly Ordered Message）")]),r._v(" "),a("p",[r._v("严格顺序消息模式下，消费者收到的所有消息均是有顺序的。")]),r._v(" "),a("h3",{attrs:{id:"消息-message"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息-message"}},[r._v("#")]),r._v(" 消息（Message）")]),r._v(" "),a("p",[r._v("消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ 中每个消息拥有唯一的 Message ID，且可以携带具有业务标识的 Key。系统提供了通过 Message ID 和 Key 查询消息的功能。")]),r._v(" "),a("h3",{attrs:{id:"标签-tag"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标签-tag"}},[r._v("#")]),r._v(" 标签（Tag）")]),r._v(" "),a("p",[r._v("为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统。消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性。")]),r._v(" "),a("h3",{attrs:{id:"基本模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本模型"}},[r._v("#")]),r._v(" 基本模型")]),r._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/rocketmq/1/img.png",alt:""}})]),r._v(" "),a("h2",{attrs:{id:"架构设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构设计"}},[r._v("#")]),r._v(" 架构设计")]),r._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/rocketmq/1/img_1.png",alt:""}})]),r._v(" "),a("h3",{attrs:{id:"技术架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#技术架构"}},[r._v("#")]),r._v(" 技术架构")]),r._v(" "),a("p",[r._v("Producer：消息发布的角色，支持分布式集群方式部署。Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。")]),r._v(" "),a("p",[r._v("Consumer：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。")]),r._v(" "),a("p",[r._v("NameServer：NameServer 是一个非常简单的 Topic 路由注册中心，其角色类似 Dubbo 中的 zookeeper，支持 Broker 的动态注册与发现。主要包括两个功能：Broker 管理，NameServer 接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查 Broker 是否还存活；路由信息管理，每个 NameServer 将保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息。然后 Producer 和 Conumser 通过 NameServer 就可以知道整个 Broker 集群的路由信息，从而进行消息的投递和消费。NameServer 通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker 是向每一台 NameServer 注册自己的路由信息，所以每一个 NameServer 实例上面都保存一份完整的路由信息。当某个 NameServer 因某种原因下线了，Broker 仍然可以向其它 NameServer 同步其路由信息，Producer,Consumer 仍然可以动态感知 Broker 的路由的信息。")]),r._v(" "),a("p",[r._v("BrokerServer：Broker 主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker 包含了以下几个重要子模块：")]),r._v(" "),a("ul",[a("li",[r._v("Remoting Module：整个 Broker 的实体，负责处理来自 clients 端的请求。")]),r._v(" "),a("li",[r._v("Client Manager：负责管理客户端 (Producer/Consumer) 和维护 Consumer 的 Topic 订阅信息")]),r._v(" "),a("li",[r._v("Store Service：提供方便简单的 API 接口处理消息存储到物理硬盘和查询功能。")]),r._v(" "),a("li",[r._v("HA Service：高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能。")]),r._v(" "),a("li",[r._v("Index Service：根据特定的 Message key 对投递到 Broker 的消息进行索引服务，以提供消息的快速查询。")])]),r._v(" "),a("h3",{attrs:{id:"部署架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#部署架构"}},[r._v("#")]),r._v(" 部署架构")]),r._v(" "),a("p",[r._v("NameServer 是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。")]),r._v(" "),a("p",[r._v("Broker 部署相对复杂，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 与 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，BrokerId 为 0 表示 Master，非 0 表示 Slave。Master 也可以部署多个。每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer。 注意：当前 RocketMQ 版本在部署架构上支持一 Master 多 Slave，但只有 BrokerId=1 的从服务器才会参与消息的读负载。")]),r._v(" "),a("p",[r._v("Producer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master 发送心跳。Producer 完全无状态，可集群部署。")]),r._v(" "),a("p",[r._v("Consumer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave 发送心跳。Consumer 既可以从 Master 订阅消息，也可以从 Slave 订阅消息，消费者在向 Master 拉取消息时，Master 服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读 I/O），以及从服务器是否可读等因素建议下一次是从 Master 还是 Slave 拉取。")]),r._v(" "),a("p",[r._v("结合部署架构图，描述集群工作流程：")]),r._v(" "),a("ul",[a("li",[r._v("启动 NameServer，NameServer 起来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。")]),r._v(" "),a("li",[r._v("Broker 启动，跟所有的 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息 (IP + 端口等) 以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。")]),r._v(" "),a("li",[r._v("收发消息前，先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。")]),r._v(" "),a("li",[r._v("Producer 发送消息，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker 发消息。")]),r._v(" "),a("li",[r._v("Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。")])]),r._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/apache/rocketmq/tree/master/docs/cn",target:"_blank",rel:"noopener noreferrer"}},[r._v("中文网地址"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=t.exports}}]);