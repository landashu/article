(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{623:function(a,r,s){"use strict";s.r(r);var e=s(41),t=Object(e.a)({},(function(){var a=this,r=a.$createElement,s=a._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"flink-运行时的组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flink-运行时的组件"}},[a._v("#")]),a._v(" flink 运行时的组件")]),a._v(" "),s("p",[s("img",{attrs:{src:"/assets/img/flink/4/img.png",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"jobmanager"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jobmanager"}},[a._v("#")]),a._v(" JobManager")]),a._v(" "),s("p",[a._v("控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的 JobManager 所控制执行。")]),a._v(" "),s("p",[a._v('JobManager 会先接收到要执行的应用程序，这个应用程序回包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有类、库和其他资源的 JAR 包。JobManager 会把 JobGraph 转换成一个物理层面的数据流图，这个图被叫做 "执行图"，包含了所有可以并发执行的任务。')]),a._v(" "),s("p",[a._v("JobManager 会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（Slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行他们的 TaskManager 上。而在运行过程中，JobManager 会负载所有需要中央协调的操作，比如说检查点（checkpoints）的协调。")]),a._v(" "),s("h3",{attrs:{id:"taskmanager"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#taskmanager"}},[a._v("#")]),a._v(" TaskManager")]),a._v(" "),s("p",[a._v("Flink 中的工作进程。通常在 Flink 中会有多个 TaskManager 运行，每一个 TaskManager 都包含了一定数量的插槽（slots）。插槽的数量限制了 TaskManager 能够执行的任务数量。启动之后，TaskManager 会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager 就会将一个或者多个插槽提供给 JobManager 调用。JobManager 就可以向插槽分配任务（tasks）来执行了。")]),a._v(" "),s("p",[a._v("在执行过程中，一个 TaskManager 可以跟其他运行同一应用程序的 TaskManager 交换数据。")]),a._v(" "),s("h3",{attrs:{id:"resourcemanager"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resourcemanager"}},[a._v("#")]),a._v(" ResourceManager")]),a._v(" "),s("p",[a._v("主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManager 插槽是 Flink 中定义的处理资源单元。")]),a._v(" "),s("p",[a._v("Flink 为不同的环境和资源管理工具提供了不同资源管理器，比如 YARN、MEsos、K8s，以及 standalone 部署。")]),a._v(" "),s("p",[a._v("当 JobManager 申请插槽资源时，ResourceManager 会将有空闲插槽的 TaskManager 分配给 JobManager。如果 ResourceManager 没有足够的插槽来满足 JobManager 的请求，它还可以向资源提供平台发起会话，以提供启动 TaskManager 进程的容器。")]),a._v(" "),s("h3",{attrs:{id:"dispatcher"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dispatcher"}},[a._v("#")]),a._v(" Dispatcher")]),a._v(" "),s("p",[a._v("可以跨作业运行，它为 应用提交提供了 REST 接口。当一个应用被提交执行时，分发器就会启动并将移交给一个 JobManager。Dispatcher 也会启动一个 Web UI，用来方便地展示和监控作业执行的信息。")]),a._v(" "),s("p",[a._v("Dispatcher 在架构中可能并不是必须的，这取决于应用提交运行的方式。")]),a._v(" "),s("h2",{attrs:{id:"任务提交流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#任务提交流程"}},[a._v("#")]),a._v(" 任务提交流程")]),a._v(" "),s("h3",{attrs:{id:"任务提交过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#任务提交过程"}},[a._v("#")]),a._v(" 任务提交过程")]),a._v(" "),s("p",[s("img",{attrs:{src:"/assets/img/flink/4/img_1.png",alt:""}})]),a._v(" "),s("h3",{attrs:{id:"yarn-模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#yarn-模式"}},[a._v("#")]),a._v(" YARN 模式")]),a._v(" "),s("p",[s("img",{attrs:{src:"/assets/img/flink/4/img_2.png",alt:""}})]),a._v(" "),s("h4",{attrs:{id:"详细提交流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#详细提交流程"}},[a._v("#")]),a._v(" 详细提交流程")]),a._v(" "),s("ol",[s("li",[a._v("Flink 任务提交后，client 向 HDFS 上传 Flink 的 jar 包和配置")]),a._v(" "),s("li",[a._v("Client 向 Yarn ResourceManager 提交任务")]),a._v(" "),s("li",[a._v("ResourceManager 分配 Container 资源并通知对应的 NodeManager 启动 ApplicationMaster")]),a._v(" "),s("li",[a._v("ApplicationMaster 启动后加载 Flink 的 jar 包和配置构建环境")]),a._v(" "),s("li",[a._v("ApplicationMaster 启动 JobManager")]),a._v(" "),s("li",[a._v("ApplicationMaster 向 ResourceManager 申请资源启动 TaskManager")]),a._v(" "),s("li",[a._v("ResourceManager 分配 Container 资源后")]),a._v(" "),s("li",[a._v("由 ApplicationMaster 通知资源所在节点的 NodeManager 启动 TaskManager")]),a._v(" "),s("li",[a._v("NodeManager 加载 Flink 的 jar 包和配置构建环境并启动 TaskManager")]),a._v(" "),s("li",[a._v("TaskManager 启动后向 JobManager 发送心跳包")]),a._v(" "),s("li",[a._v("等待 JobManager 向其分配任务")])]),a._v(" "),s("h4",{attrs:{id:"优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[a._v("#")]),a._v(" 优缺点")]),a._v(" "),s("p",[a._v("YARN 资源的统一管理和调度。Yarn 集群中所有节点的资源（内存、CPU、磁盘、网络等）被抽象为 Container。计算框架需要资源进行运算任务时需要向 Resource Manager 申请 Container，Yarn 按照特定的策略对资源进行调度和进行 Container 的分配。Yarn 模式能通过多种任务调度策略来利用提高集群资源利用率。例如 FIFO Scheduler、Capacity Scheduler、Fair Scheduler，并能设置任务优先级。")]),a._v(" "),s("p",[a._v("资源隔离。Yarn 使用了轻量级资源隔离机制 Cgroups 进行资源隔离以避免相互干扰，一旦 Container 使用的资源量超过事先定义的上限值，就将其杀死。")]),a._v(" "),s("p",[a._v("自动 failover 处理。例如 Yarn NodeManager 监控、Yarn ApplicationManager 异常恢复。")]),a._v(" "),s("h2",{attrs:{id:"taskmanager-与-slots"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#taskmanager-与-slots"}},[a._v("#")]),a._v(" TaskManager 与 Slots")]),a._v(" "),s("p",[s("img",{attrs:{src:"/assets/img/flink/4/img_3.png",alt:""}})]),a._v(" "),s("p",[a._v("Flink 中每一个 worker（TaskManager）都是一个 JVM 进程，它可能会在独立的线程上执行一个或多个 subtask。为了控制一个 worker 能接收多少个 task，worker 通过 task slot 来进行控制（一个 worker 至少有一个 taskslot）")]),a._v(" "),s("p",[a._v("每个 task slot 表示 TaskManager 拥有资源的一个固定大小的子集。 假如一个 TaskManager 有三个 slot，那么它会将其管理的内存分成三份给各个 slot。资源 slot 化意味着一个 subtask 将不需要跟来自其他 job 的 subtask 竞争被管理的内存，取而代之的是它将拥有一定数量的内存储备。 需要注意的是，这里不会涉及到 CPU 的隔离（CPU 是靠抢的），slot 目前仅仅用来隔离 task 的受管理的内存。")]),a._v(" "),s("p",[a._v("通过调整 task slot 的数量，允许用户定义 subtask 之间如何互相隔离。如果一个 TaskManager 一个 slot，那将意味着每个 task group 运行在独立的 JVM 中（该 JVM 可能是通过一个特定的容器启动的），而一个 TaskManager 多个 slot 意味着更多的 subtask 可以共享同一个 JVM。而在同一个 JVM 进程中的 task 将共享 TCP 连接（基于多路复用）和心跳消息。它们也可能共享数据集和数据结构，因此这减少了每个 task 的负载。")]),a._v(" "),s("p",[a._v("默认情况下，Flink 允许子任务共享 slot，即使他们是不同任务的子任务（前提是他们来自同一个 job）。 这样的结果是，一个 slot 可以保存作业的整个管道。")]),a._v(" "),s("p",[a._v("Task Slot 是静态的概念，是指 TaskManager 具有的并发执行能力，可以通过参数 taskmanager.numberOfTaskSlots 进行配置")]),a._v(" "),s("p",[a._v("并行度 parallelism 是动态概念，即 TaskManager 运行程序时实际使用的并发能力，可以通过参数 parallelism.default 进行配置。")]),a._v(" "),s("p",[a._v("设一共有 3 个 TaskManager，每一个 TaskManager 中的分配 3 个 TaskSlot，也就是每个 TaskManager 可以接收 3 个 task，一共 9 个 TaskSlot，如果我们设置 parallelism.default=1，即运行程序默认的并行度为 1，9 个 TaskSlot 只用了 1 个，有 8 个空闲，因此，设置合适的并行度才能提高效率。")]),a._v(" "),s("h2",{attrs:{id:"并行度-parallelism"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并行度-parallelism"}},[a._v("#")]),a._v(" 并行度（Parallelism）")]),a._v(" "),s("p",[a._v("Flink 程序的执行具有并行、分布式的特性")]),a._v(" "),s("p",[a._v("在执行过程中，一个流（stream）包含一个或多个分区（stream partition），而每一个算子（operator）可以包含一个或多个子任务（operator subtask），这些子任务在不同的线程、不同的物理机或不同的容器中彼此互不依赖地执行。")]),a._v(" "),s("p",[a._v("一个特定算子的子任务（subtask）的个数被称之为其并行度（parallelism）")]),a._v(" "),s("p",[a._v("一般情况下，一个流程序的并行度，可以认为就是其所有算子中最大的并行度。一个程序中，不同的算子可能具有不同的并行度。")]),a._v(" "),s("p",[a._v("Stream 在算子之间传输数据的形式可以是 one-to-one (forwarding) 的模式也可以是 redistributing 的模式，具体是哪一种形式，取决于算子的种类。")]),a._v(" "),s("ol",[s("li",[a._v("one-to-one：stream (比如在 source 和 map operator 之间) 维护着分区以及元素的顺序。那意味着 map 算子的子任务看到的元素的个数以及顺序跟 source 算子的子任务生产的元素的个数、顺序相同，map、fliter、flatMap 等算子都是 one-to-one 的对应关系。类似于 spark 中的窄依赖")]),a._v(" "),s("li",[a._v("redistributing（重新分配）：stream (map () 跟 keyBy/window 之间或者 keyBy/window 跟 sink 之间) 的分区会发生改变。每一个算子的子任务依据所选择的 transformation 发送数据到不同的目标任务。例如，keyBy () 基于 hashCode 重分区、broadcast 和 rebalance 会随机重新分区，这些算子都会引起 redistribute 过程，而 redistribute 过程就类似于 Spark 中的 shuffle 过程。类似于 spark 中的宽依赖")])]),a._v(" "),s("h2",{attrs:{id:"任务链-operator-chains"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#任务链-operator-chains"}},[a._v("#")]),a._v(" 任务链（Operator Chains）")]),a._v(" "),s("p",[a._v("相同并行度的 one to one 操作，Flink 这样相连的算子链接在一起形成一个 task，原来的算子成为里面的一部分")]),a._v(" "),s("p",[a._v("将算子链接成 task 是非常有效的优化：它能减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。")]),a._v(" "),s("p",[a._v("链接的行为可以在编程 API 中进行指定；任务链必须满足两个条件：one-to-one 的数据传输并且并行度相同")])])}),[],!1,null,null,null);r.default=t.exports}}]);