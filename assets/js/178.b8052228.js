(window.webpackJsonp=window.webpackJsonp||[]).push([[178],{655:function(e,_,v){"use strict";v.r(_);var r=v(41),t=Object(r.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"_1-1-应用部署方式演变"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-应用部署方式演变"}},[e._v("#")]),e._v(" 1.1 应用部署方式演变")]),e._v(" "),v("p",[e._v("在部署应用程序的方式上，主要经历了三个时代：")]),e._v(" "),v("ul",[v("li",[v("p",[v("strong",[e._v("传统部署")]),e._v("：互联网早期，会直接将应用程序部署在物理机上")]),e._v(" "),v("blockquote",[v("p",[e._v("优点：简单，不需要其它技术的参与"),v("br"),e._v("\n缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("虚拟化部署")]),e._v("：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境")]),e._v(" "),v("blockquote",[v("p",[e._v("优点：程序环境不会相互产生影响，提供了一定程度的安全性"),v("br"),e._v("\n缺点：增加了操作系统，浪费了部分资源")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("容器化部署")]),e._v("：与虚拟化类似，但是共享了操作系统")]),e._v(" "),v("blockquote",[v("p",[e._v("优点："),v("br"),e._v("\n可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等"),v("br"),e._v("\n运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦"),v("br"),e._v("\n容器化的应用程序可以跨云服务商、跨 Linux 操作系统发行版进行部署")])])])]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/kubernetes/600/img.png",alt:""}})]),e._v(" "),v("p",[e._v("容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：")]),e._v(" "),v("ul",[v("li",[e._v("一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器")]),e._v(" "),v("li",[e._v("当并发访问量变大的时候，怎么样做到横向扩展容器数量")])]),e._v(" "),v("p",[e._v("这些容器管理的问题统称为"),v("strong",[e._v("容器编排")]),e._v("问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("Swarm")]),e._v("：Docker 自己的容器编排工具")]),e._v(" "),v("li",[v("strong",[e._v("Mesos")]),e._v("：Apache 的一个资源统一管控的工具，需要和 Marathon 结合使用")]),e._v(" "),v("li",[v("strong",[e._v("Kubernetes")]),e._v("：Google 开源的的容器编排工具")])]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/kubernetes/600/img_1.png",alt:""}})]),e._v(" "),v("h2",{attrs:{id:"_1-2-kubernetes简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-kubernetes简介"}},[e._v("#")]),e._v(" 1.2 kubernetes 简介")]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/kubernetes/600/img_2.png",alt:""}})]),e._v(" "),v("p",[e._v("kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器 ----Borg 系统的一个开源版本，于 2014 年 9 月发布第一个版本，2015 年 7 月发布第一个正式版本。")]),e._v(" "),v("p",[e._v("kubernetes 的本质是"),v("strong",[e._v("一组服务器集群")]),e._v("，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("自我修复")]),e._v("：一旦某一个容器崩溃，能够在 1 秒中左右迅速启动新的容器")]),e._v(" "),v("li",[v("strong",[e._v("弹性伸缩")]),e._v("：可以根据需要，自动对集群中正在运行的容器数量进行调整")]),e._v(" "),v("li",[v("strong",[e._v("服务发现")]),e._v("：服务可以通过自动发现的形式找到它所依赖的服务")]),e._v(" "),v("li",[v("strong",[e._v("负载均衡")]),e._v("：如果一个服务起动了多个容器，能够自动实现请求的负载均衡")]),e._v(" "),v("li",[v("strong",[e._v("版本回退")]),e._v("：如果发现新发布的程序版本有问题，可以立即回退到原来的版本")]),e._v(" "),v("li",[v("strong",[e._v("存储编排")]),e._v("：可以根据容器自身的需求自动创建存储卷")])]),e._v(" "),v("h2",{attrs:{id:"_1-3-kubernetes组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-kubernetes组件"}},[e._v("#")]),e._v(" 1.3 kubernetes 组件")]),e._v(" "),v("p",[e._v("一个 kubernetes 集群主要是由"),v("strong",[e._v("控制节点 (master)")]),e._v("、** 工作节点 (node)** 构成，每个节点上都会安装不同的组件。")]),e._v(" "),v("p",[v("strong",[e._v("master：集群的控制平面，负责集群的决策 (管理)")])]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("ApiServer")]),e._v(" : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API 注册和发现等机制"),v("br"),e._v(" "),v("strong",[e._v(" Scheduler")]),e._v(" : 负责集群资源调度，按照预定的调度策略将 Pod 调度到相应的 node 节点上"),v("br"),e._v(" "),v("strong",[e._v(" ControllerManager")]),e._v(" : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等"),v("br"),e._v(" "),v("strong",[e._v(" Etcd")]),e._v(" ：负责存储集群中各种资源对象的信息")])]),e._v(" "),v("p",[v("strong",[e._v("node：集群的数据平面，负责为容器提供运行环境 (干活)")])]),e._v(" "),v("blockquote",[v("p",[v("strong",[e._v("Kubelet")]),e._v(" : 负责维护容器的生命周期，即通过控制 docker，来创建、更新、销毁容器"),v("br"),e._v(" "),v("strong",[e._v(" KubeProxy")]),e._v(" : 负责提供集群内部的服务发现和负载均衡"),v("br"),e._v(" "),v("strong",[e._v(" Docker")]),e._v(" : 负责节点上容器的各种操作")])]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/kubernetes/600/img_3.png",alt:""}})]),e._v(" "),v("p",[e._v("下面，以部署一个 nginx 服务来说明 kubernetes 系统各个组件调用关系：")]),e._v(" "),v("ol",[v("li",[e._v("首先要明确，一旦 kubernetes 环境启动之后，master 和 node 都会将自身的信息存储到 etcd 数据库中")]),e._v(" "),v("li",[e._v("一个 nginx 服务的安装请求会首先被发送到 master 节点的 apiServer 组件")]),e._v(" "),v("li",[e._v("apiServer 组件会调用 scheduler 组件来决定到底应该把这个服务安装到哪个 node 节点上，在此时，它会从 etcd 中读取各个 node 节点的信息，然后按照一定的算法进行选择，并将结果告知 apiServer")]),e._v(" "),v("li",[e._v("apiServer 调用 controller-manager 去调度 Node 节点安装 nginx 服务")]),e._v(" "),v("li",[e._v("kubelet 接收到指令后，会通知 docker，然后由 docker 来启动一个 nginx 的 pod，pod 是 kubernetes 的最小操作单元，容器必须跑在 pod 中至此，")]),e._v(" "),v("li",[e._v("一个 nginx 服务就运行了，如果需要访问 nginx，就需要通过 kube-proxy 来对 pod 产生访问的代理这样，外界用户就可以访问集群中的 nginx 服务了")])]),e._v(" "),v("h2",{attrs:{id:"_1-4-kubernetes概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-kubernetes概念"}},[e._v("#")]),e._v(" 1.4 kubernetes 概念")]),e._v(" "),v("p",[v("strong",[e._v("Master")]),e._v("：集群控制节点，每个集群需要至少一个 master 节点负责集群的管控"),v("br"),e._v(" "),v("strong",[e._v(" Node")]),e._v("：工作负载节点，由 master 分配容器到这些 node 工作节点上，然后 node 节点上的 docker 负责容器的运行"),v("br"),e._v(" "),v("strong",[e._v(" Pod")]),e._v("：kubernetes 的最小控制单元，容器都是运行在 pod 中的，一个 pod 中可以有 1 个或者多个容器"),v("br"),e._v(" "),v("strong",[e._v(" Controller")]),e._v("：控制器，通过它来实现对 pod 的管理，比如启动 pod、停止 pod、伸缩 pod 的数量等等"),v("br"),e._v(" "),v("strong",[e._v(" Service")]),e._v("：pod 对外服务的统一入口，下面可以维护者同一类的多个 pod"),v("br"),e._v(" "),v("strong",[e._v("Label")]),e._v("：标签，用于对 pod 进行分类，同一类 pod 会拥有相同的标签"),v("br"),e._v(" "),v("strong",[e._v(" NameSpace")]),e._v("：命名空间，用来隔离 pod 的运行环境")]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/kubernetes/600/img_4.png",alt:""}})])])}),[],!1,null,null,null);_.default=t.exports}}]);