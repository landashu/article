(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{575:function(t,e,_){"use strict";_.r(e);var a=_(41),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"背景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),_("p",[t._v("主从复制，一主多从，主库提供读写功能，从库提供只读功能。当一个事务在 master 提交成功时，会把 binlog 文件同步到从库服务器上落地为 relay log 给 slave 端执行，这个过程主库是不考虑从库是否有接收到 binlog 文件，有可能出现这种情况，当主库 commit 一个事务后，数据库发生宕机，刚好它的 binlog 还没来得及传送到 slave 端，这个时候选任何一个 slave 端都会丢失这个事务，造成数据不一致情况。 为了避免出现主从数据不一致的情况，MySQL 引入了半同步复制，添加多了一个从库反馈机制，即半同步复制。这个有两种方式设置：")]),t._v(" "),_("ol",[_("li",[t._v("主库执行完事务后，同步 binlog 给从库，从库 ack 反馈接收到 binlog，主库提交 commit，反馈给客户端，释放会话；")]),t._v(" "),_("li",[t._v("主库执行完事务后，主库提交 commit ，同步 binlog 给从库，从库 ack 反馈接收到 binlog，反馈给客户端，释放会话；")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/assets/img/mysql/8/img.png",alt:""}})]),t._v(" "),_("p",[t._v("虽然满足了一主多从，读写分析，数据一致，但是，依旧有两个弊端：")]),t._v(" "),_("ol",[_("li",[t._v("写操作只能在 master 上；")]),t._v(" "),_("li",[t._v("如果 master 宕机，需要人为选择新主并重新给其他的 slave 端执行 change master；")])]),t._v(" "),_("p",[t._v("为了解决一系列问题，官方推出了 MySQL Group Replication，从 group replication 发布以后，就有 3 种方法来实现 MySQL 的高可用集群：")]),t._v(" "),_("ul",[_("li",[t._v("异步复制")]),t._v(" "),_("li",[t._v("半同步复制")]),t._v(" "),_("li",[t._v("group replication")])]),t._v(" "),_("h2",{attrs:{id:"group-replication原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#group-replication原理"}},[t._v("#")]),t._v(" Group Replication 原理")]),t._v(" "),_("p",[t._v("MySQL Group Replication 有两种模式，单主模式 single-primary mode 和多主模式 multi-primary mode，在同一个 group 内，不允许两种模式同时存在，并且若要切换到不同模式，必须修改配置后重新启动集群。")]),t._v(" "),_("h3",{attrs:{id:"_1-单主模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-单主模式"}},[t._v("#")]),t._v(" 1 单主模式")]),t._v(" "),_("p",[t._v("在单主模式下，只有一个节点可以读写，其他节点提供只读服务。单主模式下 ，当主节点宕掉，自动会根据服务器的 server_uuid 变量和 group_replication_member_weight 变量值，选择下一个 slave 谁作为主节点，group_replication_member_weight 的值最高的成员被选为新的主节点，该参数默认为 50，建议可以在节点上设置不同值；在 group_replication_member_weight 值相同的情况下，group 根据数据字典中 server_uuid 排序，排序在最前的被选择为主节点。")]),t._v(" "),_("h3",{attrs:{id:"_2-多主模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-多主模式"}},[t._v("#")]),t._v(" 2 多主模式")]),t._v(" "),_("p",[t._v("在 mysql 多主模式下，在组复制中通过 Group Replication Protocol 协议及 "),_("a",{attrs:{href:"https://www.cnblogs.com/linbingdong/p/6253479.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Paxos 协议 (一致性算法)"),_("OutboundLink")],1),t._v("，形成的整体高可用解决方案，同时增加了 certify (认证) 的概念，负责检查事务是否允许提交，是否与其它事务存在冲突，Group Replication 是由多个节点共同组成一个数据库集群，每个节点都可以单独执行事务，但是 read-write（rw）的操作只有在组内验证后才可以 commit，Read-only (RO) 事务是不需要验证可以立即执行，当一个事务在一个节点上提交之前，会在组内自动进行原子性的广播，告知其他节点变更了什么内容 / 执行了什么事务，然后为该事物建立一个全局的排序，最终，这意味着所有的服务器都以相同的顺序接收相同的事务集。因此，所有服务器都按照相同的顺序应用相同的变更集，因此它们在组中保持一致。 在多主模式下，该组的所有成员都设置为读写模式，在多主模式下，不支持 SERIALIZABLE (严格的) 事务隔离级别，且不能完全支持级联外键约束。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/assets/img/mysql/8/img_1.png",alt:""}})]),t._v(" "),_("h3",{attrs:{id:"_3-事物隔离级别补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-事物隔离级别补充"}},[t._v("#")]),t._v(" 3 事物隔离级别补充")]),t._v(" "),_("h4",{attrs:{id:"read-committed"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#read-committed"}},[t._v("#")]),t._v(" Read Committed")]),t._v(" "),_("p",[t._v("在 Read Committed 隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。"),_("br"),t._v("\n我们先准备好 students 表的数据：")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("mysql> select * from students;\n+----+-------+\n| id | name  |\n+----+-------+\n|  1 | Alice |\n+----+-------+\n1 row in set (0.00 sec)\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br")])]),_("p",[t._v("然后，分别开启两个 MySQL 客户端连接，按顺序依次执行事务 A 和事务 B：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("时刻")]),t._v(" "),_("th",[t._v("事务 A")]),t._v(" "),_("th",[t._v("事务 B")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("1")]),t._v(" "),_("td",[t._v("SET TRANSACTION ISOLATION LEVEL READ COMMITTED;")]),t._v(" "),_("td",[t._v("SET TRANSACTION ISOLATION LEVEL READ COMMITTED;")])]),t._v(" "),_("tr",[_("td",[t._v("2")]),t._v(" "),_("td",[t._v("BEGIN;")]),t._v(" "),_("td",[t._v("BEGIN;")])]),t._v(" "),_("tr",[_("td",[t._v("3")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("SELECT * FROM students WHERE id = 1;")])]),t._v(" "),_("tr",[_("td",[t._v("4")]),t._v(" "),_("td",[t._v("UPDATE students SET name = 'Bob' WHERE id = 1;")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("5")]),t._v(" "),_("td",[t._v("COMMIT;")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("6")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("SELECT * FROM students WHERE id = 1;")])]),t._v(" "),_("tr",[_("td",[t._v("7")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("COMMIT;")])])])]),t._v(" "),_("p",[t._v("当事务 B 第一次执行第 3 步的查询时，得到的结果是 Alice，随后，由于事务 A 在第 4 步更新了这条记录并提交，所以，事务 B 在第 6 步再次执行同样的查询时，得到的结果就变成了 Bob，因此，在 Read Committed 隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。")]),t._v(" "),_("h4",{attrs:{id:"serializable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#serializable"}},[t._v("#")]),t._v(" Serializable")]),t._v(" "),_("p",[t._v("Serializable 是最严格的隔离级别。在 Serializable 隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。")]),t._v(" "),_("p",[t._v("虽然 Serializable 隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用 Serializable 隔离级别。")]),t._v(" "),_("p",[t._v("默认隔离级别"),_("br"),t._v("\n如果没有指定隔离级别，数据库就会使用默认的隔离级别。在 MySQL 中，如果使用 InnoDB，默认的隔离级别是 Repeatable Read。")]),t._v(" "),_("h4",{attrs:{id:"repeatable-read"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#repeatable-read"}},[t._v("#")]),t._v(" Repeatable Read")]),t._v(" "),_("p",[t._v("在 Repeatable Read 隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("mysql> select * from students;\n+----+-------+\n| id | name  |\n+----+-------+\n|  1 | Alice |\n+----+-------+\n1 row in set (0.00 sec)\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br")])]),_("p",[t._v("然后，分别开启两个 MySQL 客户端连接，按顺序依次执行事务 A 和事务 B：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("时刻")]),t._v(" "),_("th",[t._v("事务 A")]),t._v(" "),_("th",[t._v("事务 B")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("1")]),t._v(" "),_("td",[t._v("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;")]),t._v(" "),_("td",[t._v("SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;")])]),t._v(" "),_("tr",[_("td",[t._v("2")]),t._v(" "),_("td",[t._v("BEGIN;")]),t._v(" "),_("td",[t._v("BEGIN;")])]),t._v(" "),_("tr",[_("td",[t._v("3")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("SELECT * FROM students WHERE id = 99;")])]),t._v(" "),_("tr",[_("td",[t._v("4")]),t._v(" "),_("td",[t._v("INSERT INTO students (id, name) VALUES (99, 'Bob');")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("5")]),t._v(" "),_("td",[t._v("COMMIT;")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("6")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("SELECT * FROM students WHERE id = 99;")])]),t._v(" "),_("tr",[_("td",[t._v("7")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("UPDATE students SET name = 'Alice' WHERE id = 99;")])]),t._v(" "),_("tr",[_("td",[t._v("8")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("SELECT * FROM students WHERE id = 99;")])]),t._v(" "),_("tr",[_("td",[t._v("9")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("COMMIT;")])])])]),t._v(" "),_("p",[t._v("事务 B 在第 3 步第一次读取 id=99 的记录时，读到的记录为空，说明不存在 id=99 的记录。随后，事务 A 在第 4 步插入了一条 id=99 的记录并提交。事务 B 在第 6 步再次读取 id=99 的记录时，读到的记录仍然为空，但是，事务 B 在第 7 步试图更新这条不存在的记录时，竟然成功了，并且，事务 B 在第 8 步再次读取 id=99 的记录时，记录出现了。")]),t._v(" "),_("p",[t._v("可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。")]),t._v(" "),_("h4",{attrs:{id:"read-uncommitted"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#read-uncommitted"}},[t._v("#")]),t._v(" Read Uncommitted")]),t._v(" "),_("p",[t._v("Read Uncommitted 是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。")]),t._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("mysql> select * from students;\n+----+-------+\n| id | name  |\n+----+-------+\n|  1 | Alice |\n+----+-------+\n1 row in set (0.00 sec)\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br"),_("span",{staticClass:"line-number"},[t._v("4")]),_("br"),_("span",{staticClass:"line-number"},[t._v("5")]),_("br"),_("span",{staticClass:"line-number"},[t._v("6")]),_("br"),_("span",{staticClass:"line-number"},[t._v("7")]),_("br")])]),_("p",[t._v("然后，分别开启两个 MySQL 客户端连接，按顺序依次执行事务 A 和事务 B：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("时刻")]),t._v(" "),_("th",[t._v("事务 A")]),t._v(" "),_("th",[t._v("事务 B")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("1")]),t._v(" "),_("td",[t._v("SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;")]),t._v(" "),_("td",[t._v("SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;")])]),t._v(" "),_("tr",[_("td",[t._v("2")]),t._v(" "),_("td",[t._v("BEGIN;")]),t._v(" "),_("td",[t._v("BEGIN;")])]),t._v(" "),_("tr",[_("td",[t._v("3")]),t._v(" "),_("td",[t._v("UPDATE students SET name = 'Bob' WHERE id = 1;")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("4")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("SELECT * FROM students WHERE id = 1;")])]),t._v(" "),_("tr",[_("td",[t._v("5")]),t._v(" "),_("td",[t._v("ROLLBACK;")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("6")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("SELECT * FROM students WHERE id = 1;")])]),t._v(" "),_("tr",[_("td",[t._v("7")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("COMMIT;")])])])]),t._v(" "),_("p",[t._v("当事务 A 执行完第 3 步时，它更新了 id=1 的记录，但并未提交，而事务 B 在第 4 步读取到的数据就是未提交的数据。随后，事务 A 在第 5 步进行了回滚，事务 B 再次读取 id=1 的记录，发现和上一次读取到的数据不一致，这就是脏读。可见，在 Read Uncommitted 隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。")]),t._v(" "),_("h2",{attrs:{id:"配置要求和限制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#配置要求和限制"}},[t._v("#")]),t._v(" 配置"),_("a",{attrs:{href:"https://dev.mysql.com/doc/refman/8.0/en/group-replication-requirements.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("要求"),_("OutboundLink")],1),t._v("和"),_("a",{attrs:{href:"https://dev.mysql.com/doc/refman/8.0/en/group-replication-limitations.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("限制"),_("OutboundLink")],1)]),t._v(" "),_("ul",[_("li",[t._v("inndb 存储引擎；")]),t._v(" "),_("li",[t._v("每个表需要定义显式主键；")]),t._v(" "),_("li",[t._v("隔离级别：官网建议 READ COMMITTED 级别，不支持 SERIALIZABLE 隔离级别；")]),t._v(" "),_("li",[t._v("不建议使用级联外键；")]),t._v(" "),_("li",[t._v("IPv4 网络；")]),t._v(" "),_("li",[t._v("auto_increment_increment 和 auto_increment_offset 的配置；")]),t._v(" "),_("li",[t._v("log-bin = ROW；")]),t._v(" "),_("li",[t._v("log_slave_updates = ON；")]),t._v(" "),_("li",[t._v("开启 GTID；")]),t._v(" "),_("li",[t._v("安装引擎：group_replication.so；")])]),t._v(" "),_("h2",{attrs:{id:"mysql主从可以有多少个"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql主从可以有多少个"}},[t._v("#")]),t._v(" mysql 主从可以有多少个")]),t._v(" "),_("p",[t._v("可以成为一个复制组成员的 MySQL 服务器的最大数量为 9。如果其他成员尝试加入该组，则其请求将被拒绝。从测试和基准测试中可以确定此限制是安全的边界，在此范围内，组可以在稳定的局域网上可靠地运行。")]),t._v(" "),_("h2",{attrs:{id:"auto-increment-increment"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#auto-increment-increment"}},[t._v("#")]),t._v(" auto_increment_increment")]),t._v(" "),_("p",[t._v("在服务器上启动组复制时，auto_increment_increment 的值将更改为 group_replication_auto_increment_increment 的值（默认值为 7），而 auto_increment_offset 的值将更改为服务器 ID。 停止组复制时，将还原更改。 这些设置避免为组成员上的写入选择重复的自动增量值，这会导致事务回滚。 组复制的默认自动增量值为 7，表示可用值数与复制组的允许最大大小（9 个成员）之间的平衡。")]),t._v(" "),_("p",[t._v("仅当 auto_increment_increment 和 auto_increment_offset 各自的默认值均为 1 时，才进行更改并还原。如果已将其值从默认值修改，则组复制不会更改它们。 从 MySQL 8.0 开始，当组复制处于只有一个服务器写入的单主模式下时，系统变量也不会被修改。")])])}),[],!1,null,null,null);e.default=v.exports}}]);