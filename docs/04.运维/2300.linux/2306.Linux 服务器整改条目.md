---
title: Linux 服务器整改条目
date: 2023-06-25 09:22:36
permalink:  /linux/2306
sidebar: true
article: false #  是否未非文章页，非文章不显示 面包屑和作者、时间，不显示最近更新栏，不会参与到最近更新文章的数据计算中
comment: false #  评论区
editLink: false
---


### 目标主机 showmount -e信息泄露
showmount -e 是一个用于查询 NFS（网络文件系统）服务器共享目录的命令。当目标主机启用 NFS 服务且配置不当时，攻击者可通过该命令直接获取服务器导出的目录结构（如 /data, /home 等），甚至绕过访问控制直接挂载敏感目录，导致数据泄露或未授权访问。例如：
* 信息泄露：攻击者通过 showmount -e <目标IP> 可列出所有共享目录，推测服务器功能（如数据库备份目录、用户数据目录）。
* 直接攻击：若 NFS 未限制客户端 IP，攻击者可通过 mount -t nfs <目标IP>:/敏感目录 /mnt 直接挂载并读取 / 写入数据。

**解决方案：**
1. 立即阻断 showmount -e 的访问
* 通过防火墙限制 NFS 端口访问，NFS 服务依赖端口 2049（NFS 主端口）和 111（rpcbind 端口），需仅允许可信 IP 访问：
  ```shell
  # 允许192.168.1.0/24网段访问NFS服务
  firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.0/24" port protocol="tcp" port="2049" accept'
  firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.0/24" port protocol="udp" port="2049" accept'
  firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.0/24" port protocol="tcp" port="111" accept'
  firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.1.0/24" port protocol="udp" port="111" accept'
  firewall-cmd --reload
  ```
  验证：执行 showmount -e <目标IP>，非授权 IP 应显示 clnt_create: RPC: Program not registered。
* 使用 hosts.allow/deny 限制 mountd 服务，修改 NFS 服务器的 /etc/hosts.allow 和 /etc/hosts.deny 文件：
  ```shell
  # 仅允许192.168.1.100访问mountd服务
  echo "mountd: 192.168.1.100" >> /etc/hosts.allow
  # 拒绝所有其他IP
  echo "mountd: ALL" >> /etc/hosts.deny
  ```
  生效方式：无需重启服务，立即生效。

2. 彻底修复 NFS 服务配置
* 编辑 NFS 服务器的 /etc/exports 文件，按以下原则配置：
  * 指定可信客户端：仅允许特定 IP 或网段访问。
  * 设置只读权限：非必要不开放写权限。
  * 启用 root_squash：将客户端 root 用户映射为匿名用户（nfsnobody）。
  ```shell
    # 示例：仅允许192.168.1.0/24网段只读访问/data目录，并限制root权限
    /data 192.168.1.0/24(ro,sync,root_squash)
  ```
  生效命令：exportfs -rv。
* 固定 NFS 动态端口并配置防火墙，NFS 的 LOCKD、MOUNTD 等服务默认使用随机端口，需固定端口并开放防火墙：
```shell
# 编辑/etc/sysconfig/nfs，添加以下内容
LOCKD_TCPPORT=32803
LOCKD_UDPPORT=32769
RQUOTAD_PORT=1001

# 开放固定端口
firewall-cmd --permanent --add-port=32803/tcp
firewall-cmd --permanent --add-port=32769/udp
firewall-cmd --permanent --add-port=1001/tcp
firewall-cmd --reload
```

### 目标主机支持RSA密钥交换
RSA 密钥交换是一种旧的加密方式，它不支持 “前向保密”。这意味着一旦服务器的私钥泄露，攻击者可以解密过去所有用该密钥加密的历史通信数据，存在严重的隐私和安全风险，现在已不推荐使用。而 ECDHE 等临时密钥交换算法，每次通信会生成临时密钥，即使私钥泄露，历史流量也无法被解密，更安全。

**解决方案：**
* 禁用 RSA 密钥交换算法：在服务器的 TLS 配置中，删除所有以RSA为密钥交换方式的加密套件（如RSA-AES256-GCM-SHA384等），打开 Nginx 的 SSL 配置文件（通常是nginx.conf），在server块的ssl_ciphers中，只保留以ECDHE开头的加密套件，删除所有RSA相关套件
```shell
server {
    listen 443 ssl;
    server_name example.com;
    
    # 禁用RSA密钥交换，只启用ECDHE
    ssl_protocols TLSv1.2 TLSv1.3;  # 禁用不安全的TLS版本
    ssl_prefer_server_ciphers on;
    # 只保留ECDHE相关加密套件，确保前向保密
    ssl_ciphers "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256";
}
```
* 启用 ECDHE 临时密钥交换算法：优先配置并只保留以ECDHE为前缀的加密套件（如ECDHE-ECDSA-AES256-GCM-SHA384、ECDHE-RSA-AES128-GCM-SHA256等），确保通信时使用临时密钥交换。
* 重启服务生效：修改配置后，重启 Web 服务器（如 Nginx、Apache）或 TLS 相关服务，使新配置生效。
```shell
# 检查配置是否有误
nginx -t
# 重启Nginx生效
systemctl restart nginx
```

### SSH 服务支持弱加密算法
在配置远程SSH服务器时，出于安全性考虑，应避免使用诸如arcfour、aes128-cbc、blowfish-cbc、3des-cbc等弱加密算法。

**解决方案：**
打开 SSH 的主配置文件（通常是/etc/ssh/sshd_config），在文件中添加或修改以下配置，明确禁用弱算法（arcfour、aes128-cbc、blowfish-cbc、3des-cbc），只保留安全的加密方式（如aes256-gcm@openssh.com、chacha20-poly1305@openssh.com等）
```shell
# 查看有哪些加密，但不正确，要测验看后面
ssh -Q cipher localhost

# 禁用弱加密算法，仅允许强算法
1. 打开SSH配置文件，一般位于/etc/ssh/sshd_config。
2. 在该配置文件中，找到以下这些行（如果存在的话）并删除或注释掉它们，如果不存在的话，直接跳到第3步
Ciphers aes128-cbc,aes192-cbc,aes256-cbc,MACs hmac-md5,hmac-sha1,hmac-ripemd160
3. 向配置文件添加或修改以下行以只允许使用强加密算法
Ciphers aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr
```
重启 SSH 服务使配置生效
```shell
Debian/Ubuntu：sudo systemctl restart sshd
CentOS/RHEL：sudo systemctl restart sshd
其他系统：sudo service sshd restart
```
用以下命令检查当前 SSH 服务器启用的加密算法，确认弱算法已被移除：
```shell
ssh -Q cipher localhost #ssh -Q cipher localhost 可能显示 “理论支持的算法”，而非实际启用的。最准确的验证是从客户端尝试用弱算法连接，若失败则配置生效
# no matching cipher found: client offered: aes128-cbc server supported: ...（表示弱算法被拒绝）。 配置成功
ssh -c aes128-cbc 你的用户名@服务器IP
# 尝试用强算法连接，若出现提示 Are you sure you want to continue connecting 则成功
ssh -c aes256-gcm@openssh.com 你的用户名@服务器IP
```

###  OpenSSH 用户枚举漏洞
#### CVE-2018-15473
OpenSSH 7.7及之前版本中存在用户枚举漏洞，该漏洞源于程序会对有效的和无效的用户身份验证请求发出不同的响应。攻击者可通过发送特制的请求利用该漏洞枚举用户名称。

**解决方案（看完问题）：**
该漏洞在 OpenSSH 7.7 版本中已被修复，因此最彻底的解决方式是将系统的 OpenSSH 升级到 7.7 及以上版本。
1. 查看版本
```shell
ssh -V
```
2. 通过系统包管理器升级（推荐）
```shell
# Ubuntu/Debian 系统：
sudo apt update && sudo apt upgrade openssh-server openssh-client
#CentOS/RHEL 系统
sudo yum update openssh-server openssh-clients

# Ubuntu/Debian
sudo systemctl restart sshd
# CentOS/RHEL
sudo systemctl restart sshd
```

**遇到问题**
1. 如果你的yum无法更新到最新版，以下是解决方案：
```shell
# yml 安装不成功可以尝试
sudo yum remove -y epel-release
# 然后重新尝试
```
```shell
# 示例：下载 9.6p1 版本（请替换为最新版本号）
wget https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-9.6p1.tar.gz
# 安装编译依赖：
sudo yum install -y gcc make zlib-devel openssl-devel pam-devel

# 解压
tar -zxvf openssh-9.6p1.tar.gz
cd openssh-9.6p1
# 配置编译选项（根据需要调整）

# 强制使用新安装的 OpenSSL, 是自己手动安装的 openssl，没有手动安装则去掉使用默认
# 默认 使用 ./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam --with-zlib
./configure \
  --prefix=/usr \
  --sysconfdir=/etc/ssh \
  --with-pam \
  --with-zlib \
  --with-ssl-dir=/usr/local/openssl  

# 编译并安装
make
sudo make install
```
2. openssh安装失败，提示遇到 openSSL 版本较低
```shell
# 先尝试通过包管理器升级 OpenSSL
sudo yum update openssl openssl-devel
# 检查升级后的版本
openssl version

# 手动编译安装 OpenSSL
wget https://www.openssl.org/source/openssl-1.1.1w.tar.gz
tar -zxvf openssl-1.1.1w.tar.gz
cd openssl-1.1.1w
# 配置安装路径（推荐 /usr/local/openssl）
./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl shared zlib
# 编译（多线程加速）
make -j4
# 安装
sudo make install

# 添加库文件路径
sudo echo "/usr/local/openssl/lib" >> /etc/ld.so.conf.d/openssl.conf
sudo ldconfig
# 创建软链接，替换系统默认的 openssl
sudo mv /usr/bin/openssl /usr/bin/openssl.old
sudo ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl
sudo ln -s /usr/local/openssl/include/openssl /usr/include/openssl

# 验证 OpenSSL 版本
openssl version
```
3. PAM headers not found
```shell
sudo yum install -y pam-devel
```
4. **重点** 安装好后openssh，不要重启，立马更新所有账户的密码，否则无法登录

### Nginx
#### 漏洞源于可能允许攻击者使用特制的mp4文件过度读取NGINX工作内存导致其终止
这个漏洞是指 F5 Nginx 在处理特制的 MP4 文件时，可能会出现内存读取越界的问题。攻击者可以构造恶意的 MP4 文件，当服务器处理该文件时，会错误地读取超出预期范围的内存数据，最终导致 Nginx 进程崩溃（终止运行），造成服务中断，影响可用性。

**解决方案：**
官方不处理这个漏洞，要解决这个漏洞您可以不启用这个模块`ngx_http_mp4_module`，或者已添加改密快，在用到的地方注释掉
```shell
location /video/ {
    # mp4;
    # mp4_buffer_size       1m; # mp4_buffer_size 1m; # mp4缓冲区大小 1m;
    # mp4_max_buffer_size   5m; # mp4最大缓冲区大小 5m;
    # mp4_limit_rate         on; # 限制MP4输出码率 开启;
    # mp4_limit_rate_after   30s; # 达到30秒后开始限制MP4速率
}
```

#### 漏洞源于TLS会话票证或SSL会话缓存的使用，这可能使攻击者利用会话恢复来绕过这些服务器上的客户端证书认证要求
Nginx 在使用 TLS 会话票证或 SSL 会话缓存（用于加速重复连接的 "会话恢复" 功能）时，可能存在认证漏洞。正常情况下，启用客户端证书认证（如双向 TLS 认证）时，每次连接都需要验证客户端证书；但漏洞存在时，攻击者可利用已有的会话信息（如会话票证）绕过证书验证，直接复用旧会话访问服务器，导致未授权访问。

**解决方案：（3种）**
1. 先测试升级nginx是否能解决，若不能在使用以下方式
2. 禁用 TLS 1.3 bmpqnr
```shell
server {
  listen 443 ssl;
  ssl_protocols TLSv1.2; # TLSv1.3 不要启用
}
```
3. 限制会话缓存并强制证书重验证
```shell
# 限制会话缓存大小和超时时间（建议不超过5分钟）
ssl_session_cache shared:SSL:10m;
ssl_session_timeout 5m;

ssl_verify_client on;  # 强制验证客户端证书
ssl_session_tickets off;  # 禁用会话票证
```